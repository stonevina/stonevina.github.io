### 性能优化

```
性能黄金法则：只有10%～20%的最终用户响应时间花在了下载HTML文档上，其余的80%～90%时间花在了下载页面中的所有组件（图片、脚本、样式、Flash等）中。
```

1. 减少HTTP请求**（数量）**
   - 图片地图
   - CSS Sprites
   - 内联图片
   - 合并脚本和样式表
2. 使用CDN（使用内容分发网络）**（网络）**
3. 添加Expires头 **（缓存）**
   - Expires Header
   - HTTP1.1中引入了Cache-Control的Max-Age
   - 缓存的不仅仅是图片，还包括脚本、样式、Flash组件
   - 修订文件名
4. 压缩组件 **（大小）**
   - HTTP1.1中，客户端增加Accpt-Encoding: gzip, defalte;服务端增加Content-Encoding: gzip
   - 代理缓存：Web服务器的响应增加Vary头，Vary: Accept-Encoding，代理缓存两个版本的响应，有指定Accept-Encoding和没有Accept-Encoding的
   - 边缘情况：客户端或者服务端出现错误（发送压缩内容到不支持它的客户端，忘记将压缩内容声明为已经进行了gzip编码）
5. 将样式表放在顶部 **（性能）**
   - 为避免当样式变化时重绘页面中的元素，浏览器会阻塞内容逐步呈现。将样式放在文档底部对加载页面所需的实际时间没有多大影响，浏览器等待位于底部的样式表时，浏览器会延迟显示任何可视化组件，导致白屏
   - @import可能会导致白屏，组件下载无序
   - 无样式内容的闪烁。David Hyatt：如果样式表仍在加载，构建呈现树就是一种浪费，因为在所有样式表加载并解析完毕之前无需绘制任何东西。否则，在其准备好之前显示内容会遇到FOUC（无样式内容的闪烁，Flash of Unstyled Content）问题
6. 将脚本放在底部 **（性能）**
   - 并行下载，HTTP1.1规范建议浏览器从每个主机名并行现在两个组件，并行数量限制可以修改。对于HTTP1.0，Firefox并行下载的限制是8。可以通过使用CNAME（DNS别名）来将组件分别放到多个主机名中。但增加并行下载数量是有开销的，过多的并行下载反而会降低性能
   - 脚本阻塞下载，下载脚本时并行下载实际上是被**禁用的**——即使使用了不同的主机名，浏览器也不会启动其他的下载。**其中的一个原因是，脚本可能使用`document.write`来修改页面内容，因此浏览器会等待，以确保页面能够恰当地布局。在下载脚本时浏览器阻塞并行下载的另一个原因是为了保证脚本能够按照正确的顺序执行**。
7. 避免CSS表达式**（优化）**
8. 使用外部JavaScript和CSS**（缓存）**
   - 使用内联还是外置，取决于网站类型
9. 减少DNS查找**（网络）**
   - DNS缓存和TTL
   - 减少唯一主机名的数量
   - 通过使用Keep-Alive，**持久连接**的引入解决了多对一请求服务器导致的socket连接低效性的问题。它使浏览器可以在一个单独的连接上进行多个请求。浏览器和服务器使用Connection头来指出对Kepp-Alive的支持。HTTP1.1中定义的**管道**可以在一个单独的socket上发送多个请求而无须等待响应。管道的性能要优于持久连接。Keep-Alive通过重用现有连接避免了重复的DNS查找
10. 精简JavaScript**（大小）**
    - 精简，是从代码中移除不必要的字符以减小大小，进而改善加载时间的实践
    - 混淆，移除空白和注释，同时它还会改写代码，代码更加精炼，同时也更难阅读
    - 节省
11. 避免重定向**（网络）**
12. 移除重复脚本**（性能）**
    - 重复脚本损伤性能，不必要的HTTP请求和执行JavaScript所浪费的时间
    - 避免重复脚本的方法是使用脚本管理模块
13. 配置ETag**（缓存）**
    - If-None-Match比If-Modified-Since具有更高的优先级。依据HTTP1.1规范，如果请求中同时出现了这两个头，则原始服务器**禁止**返回304，除非请求中的条件头字段全部一致
14. 使用Ajax可缓存**（缓存）**

#### 分类
- 数量：减少http数量
- 大小：压缩组件／精简js
- 网络：cdn／减少dns查找／避免重定向
- 页面性能：css头部／js底部／避免css表达式／重复的js
- 缓存：expires／外部的css和js／配置etag／ajax缓存