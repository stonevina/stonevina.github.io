### 组件化
- 发展历程
- 解决方案
- 方案对比

  - React
    - Virtual DOM

    - 生命周期
    - render
    - setState
    - diff算法
    - 创建组件的方式

  - React-router
    - 底层原理

  - Redux
    - mv\* flux演变历史
    - 三大原则
    - 底层原理
    - 性能优化

  - 服务端渲染

  - 组件间通信

  - 双向数据绑定

  - 热替换
    - 实现原理

### 模块化
- 发展历程
- 解决方案
- 方案对比

### node
  - express底层原理
  - koa底层原理
  - 两者区别、场景使用
  - 事件循环
  - 包管理机制
  - EventEmitter实现原理
  - util.promisify原理

### ES6/ES7/ES8
  - 包含的东西
  - let/const/var 区别
  - 箭头函数
  - Promise
    - 基础使用
    - 实现
  - Proxy
  - async/await
  - 装饰器

### 异步方案
  - callback
  - Promise
    - 基础使用
    - 实现
    - 适应场景、局限性
  - co generator
    - co原理
  - await/async
    - 原理
  - 执行顺序

### JS基础
  - 基本类型与引用类型
  - toString与valueOf
  - 数据类型转换
  - 闭包
  - 原型链
  - 箭头函数
  - 作用域链
  - 垃圾回收机制
  - 正则表达式
  - 事件

### Web安全
  - XSS
  - CSRF
  - 跨域
    - 原理
    - 解决方案

### 协议
  - HTTP/HTTPS/HTTP2/Spdy
  - TCP和UDP的区别
  - Websocket
  - ajax/fetch
  - option
  - 常见状态码
  - cookie

### 数据结构
  - 二叉树

### 算法
  - 动态规划
  - 排序
  - 去重
  - 深度优先
  - 给定一个数组arr，选出 n 个数的和等于m
  - 一个列表，假设有100000个数据，这个该怎么办
  - 给一个多行多空格的字符串，让你分割成三行三列的数组
  - 随意给定一个无序的、不重复的数组data，任意抽取n个数，相加和为sum，也可能无解，请写出该函数

### 性能优化
	性能黄金法则：只有10%～20%的最终用户响应时间花在了下载HTML文档上，其余的80%～90%时间花在了下载页面中的所有组件（图片、脚本、样式、Flash等）中。
1. 减少HTTP请求**（数量）**
  - 图片地图
  - CSS Sprites
  - 内联图片
  - 合并脚本和样式表
2. 使用CDN（使用内容分发网络）**（网络）**
3. 添加Expires头 **（缓存）**
  - Expires Header
  - HTTP1.1中引入了Cache-Control的Max-Age
  - 缓存的不仅仅是图片，还包括脚本、样式、Flash组件
  - 修订文件名
4. 压缩组件 **（大小）**
  - HTTP1.1中，客户端增加Accpt-Encoding: gzip, defalte;服务端增加Content-Encoding: gzip
  - 代理缓存：Web服务器的响应增加Vary头，Vary: Accept-Encoding，代理缓存两个版本的响应，有指定Accept-Encoding和没有Accept-Encoding的
  - 边缘情况：客户端或者服务端出现错误（发送压缩内容到不支持它的客户端，忘记将压缩内容声明为已经进行了gzip编码）
5. 将样式表放在顶部 **（性能）**
  - 为避免当样式变化时重绘页面中的元素，浏览器会阻塞内容逐步呈现。将样式放在文档底部对加载页面所需的实际时间没有多大影响，浏览器等待位于底部的样式表时，浏览器会延迟显示任何可视化组件，导致白屏
  - @import可能会导致白屏，组件下载无序
  - 无样式内容的闪烁。David Hyatt：如果样式表仍在加载，构建呈现树就是一种浪费，因为在所有样式表加载并解析完毕之前无需绘制任何东西。否则，在其准备好之前显示内容会遇到FOUC（无样式内容的闪烁，Flash of Unstyled Content）问题
6. 将脚本放在底部 **（性能）**
  - 并行下载，HTTP1.1规范建议浏览器从每个主机名并行现在两个组件，并行数量限制可以修改。对于HTTP1.0，Firefox并行下载的限制是8。可以通过使用CNAME（DNS别名）来将组件分别放到多个主机名中。但增加并行下载数量是有开销的，过多的并行下载反而会降低性能
  - 脚本阻塞下载，下载脚本时并行下载实际上是被**禁用的**——即使使用了不同的主机名，浏览器也不会启动其他的下载。**其中的一个原因是，脚本可能使用`document.write`来修改页面内容，因此浏览器会等待，以确保页面能够恰当地布局。在下载脚本时浏览器阻塞并行下载的另一个原因是为了保证脚本能够按照正确的顺序执行**。
7. 避免CSS表达式**（优化）**
8. 使用外部JavaScript和CSS**（缓存）**
  - 使用内联还是外置，取决于网站类型
9. 减少DNS查找**（网络）**
  - DNS缓存和TTL
  - 减少唯一主机名的数量
  - 通过使用Keep-Alive，**持久连接**的引入解决了多对一请求服务器导致的socket连接低效性的问题。它使浏览器可以在一个单独的连接上进行多个请求。浏览器和服务器使用Connection头来指出对Kepp-Alive的支持。HTTP1.1中定义的**管道**可以在一个单独的socket上发送多个请求而无须等待响应。管道的性能要优于持久连接。Keep-Alive通过重用现有连接避免了重复的DNS查找
10. 精简JavaScript**（大小）**
  - 精简，是从代码中移除不必要的字符以减小大小，进而改善加载时间的实践
  - 混淆，移除空白和注释，同时它还会改写代码，代码更加精炼，同时也更难阅读
  - 节省
11. 避免重定向**（网络）**
12. 移除重复脚本**（性能）**
  - 重复脚本损伤性能，不必要的HTTP请求和执行JavaScript所浪费的时间
  - 避免重复脚本的方法是使用脚本管理模块
13. 配置ETag**（缓存）**
  - If-None-Match比If-Modified-Since具有更高的优先级。依据HTTP1.1规范，如果请求中同时出现了这两个头，则原始服务器**禁止**返回304，除非请求中的条件头字段全部一致
14. 使用Ajax可缓存**（缓存）**
### 设计模式
  - 面向对象
  - 函数式编程

### 构建工具
  - webpack
    - 基础配置
    - 原理
    - 优化手段
  - gulp
    - 原理
  - 其他工具
    - rollup
  - 工具比较
  - babel
    - 原理

### 跨终端
  - ReactNative
  - weex
  - nw
  - electron

### 测试
  - 单元测试
  - e2e测试

### HTML
  - 常用标签
  - 内联元素与块级元素都有哪些以及区别
  - img标签
  - html5新增属性
  - data-xxx属性作用
  - 标准模式和怪异模式
  - box-sizing
  - script异步方式

### CSS
  - 选择器
  - 权重
  - 动画
  - 动画性能优化
  - position
  - float
  - flex
  - bfc
  - ifc
  - 移动端适配
  - 双飞翼
  - 圣杯
  - 垂直水平居中

### 新技术
  - pwa
  - 可视化
  - iot
  - 机器学习

### linux
  - 常用命令
  - docker

