## 第1章 理解Ajax性能
> 过早地优化是万恶之源

### 1.1 权衡
项目三角形：时间、质量和成本

### 1.2 优化原则

优化的目的是希望降低程序的整体开销，开销就是程序的运行时间，我们更应该**把重点放在对程序整体开销影响最大的部分**

仔细观察程序的执行时间后，我们发现其实大部分时间消耗在**循环上**，3条错误轴线：

- 低效线，与之相交会降低用户的关注度，并使用户烦躁不安
- 受挫线，与之相交则意味着用户会意识到自己在被迫等待，这会导致他开始考虑其他事情
- 失败线，指由于应用崩溃或浏览器自己产生一个对话框，告诉用户应用失败需要采取行动，这时用户只好刷新或关闭浏览器

避免与错误轴线相交的3种方法：减少每次迭代的开销、减少迭代的次数或重新设计应用程序

### 1.3 Ajax

网页通常内容多、代码量大且组成部分众多，在这之间的跳转会带来巨大的开销。因此对于连续页面之间差别很小的应用而言，使用Ajax技术能带来显著的改善。

如果想通过Ajax方法对性能有积极的影响，采取正确的分工至关重要，数据包应该尽可能地小

### 1.4 浏览器

运行程序的最大开销往往是DOM而非JavaScript

### 1.5 哇

当使用不当时，这些酷炫的特性会由于分散用户的注意力或强迫用户等待连续动画播放完毕从而降低他们的生产效率。酷炫特效应该只在确实能改善用户体验时才使用，而不应用于炫耀或弥补功能与可用上的缺陷

### 1.6 JavaScript

瓶颈不是JavaScript而是DOM，避免使用那些传说中的奇技淫巧，如果必须使用，首先需要评估

### 1.7 总结

一切都是权衡。不要浪费时间去尝试为那些不消耗大量时间的代码提速。评估优先，拒绝任何不能提供良好效益的优化。

为质量编程，简洁、易读且条理分明的代码更易于正确理解、维护和优化。避免小聪明，除非可以证明他们能大幅提升性能

## 第2章 创建快速响应的Web应用

基于用户界面的需求，Web应用和传统桌面应用有一个共同的目标：**尽可能快地响应用户输入**

**浏览器用户界面的工作原理**：当用户和浏览器交互时，操作系统接收到和计算机连接的各种设备，如键盘或鼠标的输入，在判断哪个应用应该接收这些输入之后，将它们打包为**单独事件**并放置到该应用的事件队列中。

像所有GUI应用程序一样，浏览器按队列顺序完成其队列中单独事件的处理。它按照**先进先出**的顺序把它们从队列中取出，然后决定如何处理这个事件。通常，浏览器将基于这些事件做如下操作：**对事件本身进行处理（例如显示菜单、浏览网页、显示设定画面等）或执行网页自身的JavaScript代码（例如页面单击事件处理程序的JavaScript代码）**。这个处理过程实质上是**单线程的**。也就是说，浏览器使用单线程从队列中取出事件，然后对事件本身进行处理或执行JavaScript。因此，浏览器每次只能处理这些任务中的一个，并且任意一个任务都能阻止其他任务的执行。

浏览器在执行页面的JavaScript期间无法响应其他的用户事件。因此，尽可能快地执行完页面中所有的JavaScript是极其重要的，否则网页和浏览器本身可能变得非常缓慢甚至完全冻结。

### 2.1 怎样才算足够快

Jokob Nielsen：基于Web应用的响应时间准则

- 0.1秒：用户直接操作UI中对象的感觉极限
- 0.2～1.0秒：意味着会被用户注意到，因此感觉到计算机处理对指令的“处理中”
- 1秒：用户随意地在计算机指令空间进行操作而无需过度等待的感觉极限
- 10秒：用户专注任务的极限

### 2.2 测试延迟时间

精确测量延迟时间的两种方式：手动代码检测（**记录**）、自动代码检测（**性能分析**）

手动代码检测，为函数添加计时器

```javascript
function myJavaScriptFunction() {
    var start = new Date().getMilliseconds();
    
    // 这里是一些开销很大的代码
    
    var executionTime = stop - start;
    alert("myJavaScriptFunction() executed in " + executionTime + " milliseconds");
}
```

自动代码检测，借助工具来测量，例如Firebug的性能分析器

### 2.3 线程处理

传统的解决方案是使用**多线程**来把开销很大的代码从与用户交互的线程中剥离出来。

> Brendan Eich：多线程在各个方面违反了抽象概念，主要是产生了竞争状态、死锁的风险和悲观锁定开销，并且它们无法横向扩展去处理未来超级内核的亿万次计算能力。

### 2.4 确保响应速度

多任务并发执行却没有线程之间相互侵入危险的方法，首先是Google的浏览器插件Gears实现了`WorkerPool API`，允许浏览器的主JavaScript线程创建后台的`Worker`，在这些`Worker`启用时从浏览器线程中接收到一些简单的信息（如独立状态，而不是对共享变量的引用），并且在完成时返回一条信心。之后其他浏览器基于HTML5规范实现了`Web  Workers`

#### 2.4.1 Web Workers

页面上任务开销可能很大的JavaScript操作都应该委托给Worker

#### 2.4.2 Gears

对于不支持Web Worker的浏览器可以选择使用Gears

#### 2.4.3 定时器

把运行时间很长的计算拆成独立的区块，然后使用JavaScript的定时器控制其执行

```javascript
var functionState = {};

function expensiveOperation() {
    var startTime = new Date().getMilliseconds();
    while((new Date().getMilliseconds() - startTime) < 100) {
        // TODO：它用如下方法执行开销很大的运算
        // 它在迭代的语句中执行100毫秒内完成的工作，
        // 然后修改本函数外部"functionState"中的状态
        // 祝你好运。；-)
    }
    
    if (!functionState.isFinished) {
        // 退出10毫秒后再执行expensiveOperation；
        // 用较大的值进行试验，以在UI响应速度和性能上取得合适的平衡
        setTimeout(expensiveOperation, 10);
    }
}
```

采用这种方式并非真正使用计算机的**多核**，而是强制使用一核来完成所有的运算

XMLHttpRequest分为同步和异步，异步模式中XHR实质上就是一个拥有专用API的Web Worker。而同步模式下，XHR的行为就像在浏览器的主线程中执行它所有的工作一样

#### 2.4.4 内存使用对响应时间的影响

创建快速响应网页的另一个关键方面是：**内存管理**。JavaScript像许多现代的高级语言一样把低级的内存管理抽象出来，绝大部分的运行环境都实现了垃圾回收。

然而，自动内存管理是有开销的。**当执行回收时，GC实现中最复杂的几乎是"stop the world"，它们会冻结整个运行环境（包括我们正在调用的主浏览器JavaScript线程），直至遍历完整个创建对象的“堆”**。在这个过程中，它们查找那些不再使用或能够回收未用内存的对象。

对于大部分应用程序而言，GC是完全透明的；因为冻结运行环境的时间短可以完全避开用户的注意。但随着应用程序内存占用的增加，遍历整个堆去查找不再使用的对象所需要的时间将增长并最终会达到引起用户注意的程度。

当这种情况发生时，应用程序开始定期地出现间隙式迟钝，或者整个浏览器出现顶起的冻结。

#### 2.4.5 虚拟内存

内存分页是内存相关的另一种风险。**操作系统为应用提供两种可用的内存：物理的和虚拟的**。物理内存映射在基础计算机中极快的RAM芯片上；虚拟内存映射到非常慢的海量存储设备上（比如硬盘），它用更大的可用存储空间弥补了内存的相对狭小。

如果网页的内存需求增长到足够大，可能会迫使操作系统开始**内存分页**，一个极慢的进程凭借迫使其他进程放弃真正的内存来给浏览器不断增长的需求腾出空间。之所以使用术语——分页，是因为所有的现代操作系统把内存组织到独立的页面上，这个术语描述了映射到物理或虚拟内存上的最小内存单元。当分页发生时，系统把内存页从物理内存转移到虚拟内存（例如从RAM到硬盘）上，反之亦然。

分页导致的性能降低和GC停顿有一点不同；**分页会导致全面的、无处不在的迟钝，而GC停顿往往会导致离散且孤立的停顿，它们会间歇式的发生并且停顿的时间会随时间而增长**。

#### 2.4.6 内存问题的疑难解答

解决内存问题的两种方式

- 使用delete关键字从内存中移除不再需要的JavaScript对象
- 从网页的DOM树上移除不再是必需的节点

### 2.5 总结

Ajax和Web Workers都可以减少应用主线程的运算来保持用户界面的快速响应

## 第3章 拆分初始化负载

> Web应用程序变得越来越像桌面应用程序，很大一部分的应用代码不会在启动时被使用。高级的桌面应用采用的是**插件式架构**，**允许动态加载模块**，许多Web 2.0的应用程序也都采用了这种方式，并从中受益。

### 3.1 全部加载

**方案**：页面初始化时只加载必要的JavaScript，其余的JavaScript稍后再加载。

面临的问题：

- 能节省多少时间？
- 如何找到需要拆分的代码？
- 怎样处理竞争状态？
- 如何延迟加载“其余部分”的代码？

### 3.2 通过拆分来节省下流量

使用Firebug的JavaScript性能分析器就能统计当触发onload事件时有多少函数被执行。以onload事件为统计截止点是因为在此之后所需的功能可以也应该在初始化页面渲染完成时开始加载。

平均而言，在初始化页面期间有**75%的函数下载了但并未执行**，所以如果**延迟下载这些未执行的函数**，初始化时JavaScript的下载量将大大减少。

### 3.3 寻找拆分

借助Firebug的JavaScript性能分析器来显示出在触发onload之前所有已执行的函数名，这个列表可以帮助我们把要下载的JavaScript代码拆分成两个文件，一个用于页面初始化，另一个则可以延后加载。整个过程需要开发人员手动拆分。遇到的难点：

- 避免未定义标识符错误
- 一些函数未被使用，但是必需的，例如错误处理和一些条件判断代码
- 函数的作用域
- eval

**Doloto**是由微软研究院开发的自动拆分JavaScript代码的系统，它可以把代码拆分到不同的组。**第一组包括初始化网页所必需的函数，剩下的则在这些代码需要执行时按需加载它们，或者等到初始化的那些JavaScript代码加载完毕时再加载。**

### 3.4 未定义标识符合竞争状态

**在延迟加载的代码与用户界面元素相关联的情况下**，可以通过改变元素的展现来解决此问题。在这种情况下菜单可以包含一个“加载中”的图标，提醒用户该功能还没加载完成。

另一个选择是在延迟加载的代码里绑定界面元素的事件处理程序。菜单被初始化为一个静态文本，点击它不会执行任何JavaScript。

**在延迟加载的代码不与界面元素相关联的情况下**，可以使用**桩（stub）**函数解决这个问题。**桩函数是一个与原函数名称相同但是函数体为空，或者是用一些临时代码代替原有内容的函数。**

更简单的方法是给每一个被引用但又被降级为延迟下载的函数创建一个桩函数。

### 3.5 个案研究：Google日历

拆分Web应用程序的JavaScript并不是一个简单的任务。它需要明确初始化时所需的函数，找到所有必需代码的依赖关系，设置桩函数，并延迟加载其余的JavaScript。

相对于拆分JavaScript，拆分CSS也是有益的，只是**节省的资源要少一些**，因为样式表的**整体大小通常比JavaScript小**，而且**下载CSS并不会像JavaScript那样具有阻塞特性**。

## 第4章 无阻塞加载脚本

> script标签的阻塞行为会对页面性能产生负面影响。**大多数浏览器在下载或执行脚本的同时不会下载其他内容。**我们希望以不阻塞其他内容下载的方式来加载JavaScript。

### 4.1 脚本阻塞并行下载

通常，大多数浏览器是并行下载组件的，但对于**外部脚本并非如此**。**当浏览器开始下载外部脚本时，在脚本下载、解析并执行完毕之前，不会开始下载任何其他内容**。（任何已经在进程中的下载都不会被阻塞）

浏览器在下载和执行脚本时出现阻塞的原因在于，脚本可能会改变页面或JavaScript的名字空间，它们会对后续内容造成影响。**浏览器要确保按script在HTML文档中出现的顺序来执行**。

**脚本必须按顺序执行，但没有必要按顺序下载**。Internet Explorer 8是第一个支持脚本并行下载的浏览器。但并非完全解决阻塞问题，虽然实现了并行下载脚本，但**仍在脚本下载并执行完毕之前阻塞图片和iframe的下载**。

### 4.2 让脚本运行得更好

即拥有外部脚本的好处，又能避免因阻塞导致的减速影响：

- XHR Eval
- XHR注入（XHR Injection）
- Script in Iframe
- Script DOM Element
- Script Defer
- document.write Script Tag

#### 4.2.1 XHR Eval













